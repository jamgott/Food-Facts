# -*- coding: utf-8 -*-
"""CIS 545 Group 69 Annotated Notebook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XM9yoGCkySu9BXWxwKu3ynLbtx4mVIkJ

# **Nutri-Score Prediction and Classification**
###Justin Amgott, Aryan Nagariya, Kadin Donohoe

![image.png](data:image/png;base64,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)

How can we quantify and predict the nutritional value of our food, to make better choices for the health of ourselves and our communities? Here, we attempt to predict the nutrition quality of a variety of foods based on features in the Open Food Facts dataset from Kaggle. We use the Nutri-Score to explicitly quantify nutrition quality: the Nutri-Score  is an official  categorization of consumables based on their nutritional value, with an A being given to the the consumabless with the highest nutritional values, and an E being given to those with the lowest values. We use the French Nutri-Score here to take advantage of the rich dataset of items with French Nutri-Score categorization.


Currently, there are explicit rule based algorithms and classifiers used to determine the Nutri-Score of any given food item. However, with different rules for added fats (such as oils and butter), cheeses, and beverages, as well as other edge cases among products, we are interested in finding a one-size-fits-all universal classifier that can accurately model the existing Nutri-Score distribution. 
We see this being potentially very useful in real time applications for grocery store customers to get live feedback about their nutrition choices. Additionally, this classifier could help grocery stores and delivery apps evaluate new items in an unbiased manner.

Different countries apply different methodologies to compute Nutri-Score, and a category agnostic predictive output could be a useful standard. A single model is also important when streaming data; we can add each new point to a single classifier, rather than updating many classifiers at once.

## **Libraries and Data**

We import standard data analysis libraries and download the Open Food Facts dataset. 

Note: make sure to upload a personal kaggle.json API key in the /content directory before running this section.
"""

# imports 
import json
import glob
import pandas as pd
import numpy as np
import datetime as dt
import re
import os
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import cm
from google.colab import drive

!pip install kaggle

!mkdir ~/.kaggle
!cp kaggle.json ~/.kaggle/

!kaggle datasets download -d openfoodfacts/world-food-facts

!unzip /content/world-food-facts.zip

"""# **Part 1: Exploratory Data Analysis**
## 1.1 First Impressions

We begin by reading in the food facts dataset from Kaggle and storing it as a dataframe.
"""

food_df = pd.read_csv('/content/en.openfoodfacts.org.products.tsv', sep='\t', index_col=False, low_memory=False)

food_df.columns = food_df.columns.str.strip()
food_df

"""We then delete all columns that only have null entries, as such columns will be of no use. A brief look at our dataframe below shows us that there are many
columns that seem to be sparse. We will have to deal with these later if they pose an issue. The hope is that they will become less sparse as we shrink the dataset to best fit our needs.
"""

print("Number of columns before dropping null columns : %s" % (len(food_df.columns)))
food_df.dropna(axis = 1, how='all', inplace=True)
print("Number of columns after dropping null columns : %s" % (len(food_df.columns)))

"""The following is a visualization of the correlations between our numerical variables. There are numerous pairs with strong negative
or positive correlations between them.  We may want to remove variables to reduce the collinearity in our models. This chart may not be overly informative due to what looks like a high number of null values in the dataframe. However, it will be a good baseline to compare to once we have wittled down the number of null values and the number of columns.
"""

from string import ascii_letters
correlation_matrix = food_df.corr()
sns.set(style = "white")
rs = np.random.RandomState(33)
d = pd.DataFrame(data=rs.normal(size=(100, 26)),
                 columns=list(ascii_letters[26:]))
corr = correlation_matrix
mask = np.zeros_like(corr, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True
f, ax = plt.subplots(figsize=(24, 24))
cmap = sns.diverging_palette(10, 220, as_cmap=True)
sns.heatmap(corr, mask=mask, cmap=cmap, vmax=1, vmin=-1, center=0,
            square=True, linewidths=.5, cbar_kws={"shrink": .5},xticklabels=True, yticklabels=True)
plt.title("Correlation Heatmap")
sns.set(font_scale=0.1)
plt.show()

"""## 1.2 Target Variable Analysis

We now focus on our candidate target variable: nutrition_grade_fr. We note that there are two other similar non-categorical variables, nutrition-score-fr_100g, and nutrition-score-uk_100g. The first of these, nutrition-score-fr_100g is perfectly correlated with our target because there is a one to one mapping between the scores and the grades. We know this from the relevant documentation. Since we prefer to do classification models, we have chosen the nutrition grade (also known as the Nutri-Score) as our target. It then becomes of interest what to do with nutrition-score-uk_100g. As the code below shows, these columns are not identical but do have the same number of non-null entries. We then visualize the score distributions.
"""

print("The columns are identical : %s" % (food_df['nutrition-score-fr_100g'].equals(food_df['nutrition-score-uk_100g'])))
print(len(food_df[['nutrition-score-fr_100g']].dropna()))
print(len(food_df[['nutrition-score-uk_100g']].dropna()))

plt.subplots(figsize=(6, 6))
plt.scatter(food_df['nutrition-score-fr_100g'], food_df['nutrition-score-uk_100g'])
plt.plot([-20, 40], [-20, 40], 'r', linewidth=3)
plt.title("Nutrition Score UK vs Nutrition Score France")
plt.show()

"""This plot shows a strong linear relationship between the nutrition scores from France and the nutrition scores from the UK, with many points falling directly on the line y=x. However, there is a discrepancy between the way France and the UK give scores for some food items. This shows clearly that there is not unanimity on scoring or grading food.

At this point, we will drop nutrition-score-fr_100kg because it is more or less equivalent to our target. We similarly drop nutrition-score-uk_100kg because we want to make a robust model and when classifying new data points, it is not a given that we will get the nutrition score from the UK.
"""

food_df.drop('nutrition-score-uk_100g', axis=1, inplace=True)
food_df.drop('nutrition-score-fr_100g', axis=1, inplace=True)

"""Then, since we are only interested in datapoints that have a nutrition grade, we will get rid of all rows that do not have a nutrition grade, as there are far too many null occurences for imputation to be practical."""

print("Number of rows with null nutrition grade : %s" % (len(food_df)-len(food_df[['nutrition_grade_fr']].dropna())))

food_df.dropna(subset=['nutrition_grade_fr'], inplace=True)
print("Remaining number of rows : %s" % (len(food_df)))

"""Here we take a look at the distribution of grades to make sure that what we are doing is viable and that the training will not be biased to predict towards one category merely as a result of its relative frequency."""

sns.set(font_scale=1)
p = sns.countplot(x='nutrition_grade_fr', data=food_df)
p.set(title='Grade Frequencies')

food_df[["nutrition_grade_fr"]].value_counts(normalize=True)

"""There are relatively more grades of 'd' than any of the others. However, the proportions don't look wildly unbalanced. We will keep an eye on this as we continue to preprocess and may make a manual adjustment at the end if necessary, in order to maintain class balance.

## 1.3 Cross-Country Comparison

One of the things that we mentioned an interest in doing in our project proposal was comparing our target variable distributions across countries. This will only be revealing for countries that have a sufficient number of datapoints. The countries that don't have many datapoints may end up "confusing" our model when classifying for countries that do have many datapoints, especially if there is a linkage between the reason that countries have few datapoints, and the grades they are more likely to get. We therefore take it upon ourselves to delete countries that don't have at least 100 datapoints.

In this section, we find which countries have at least 100 data points and drop those that do not. We print the list of remaining countries or regions. We then join with the original dataframe.
"""

countries = food_df.groupby('countries_en', as_index=False).count()
for i in range(len(countries)) :
  if countries.at[i, 'code'] < 100 :
    countries.drop(i, inplace=True)
countries.reset_index(drop=True, inplace=True)
for i in range(len(countries)) :
  print("%s : %s" % (countries.at[i, 'countries_en'], countries.at[i, 'code']))

food_df = countries[['countries_en']].merge(food_df, how='left', on='countries_en')

"""We attempt to illustrate the above print statement graphically. The labels don't fit well. However, the tallest bar below (in pink) is the United States,
and the second tallest (yellow) is France. These two countries have
by far the most data. A look at the print statement above tells us that the countries that have at least 100 datapoints are all first world countries in Europe or the western Anglosphere. When filtering out other countries, we only lost a few thousand datapoints. It is important to keep this in mind so we know whether our model will be robust to lower income countries.
"""

p = sns.countplot(x='countries_en', data=food_df)
p.set(title='Country datapoint Frequencies')

"""Here we convert nutrition_grade_fr to a numerical variable. This will be necessary for the final analysis and will help us to properly visualize the distribution of grades across countries."""

food_df['nutrition_grade_fr'] = food_df['nutrition_grade_fr'].str.strip()
food_df = food_df.assign(nutrition_grade_fr = lambda dataframe: dataframe['nutrition_grade_fr'].map(lambda nutrition_grade_fr: 1.0 if nutrition_grade_fr == 'a' else 2.0 if nutrition_grade_fr == 'b' else 3.0 if nutrition_grade_fr == 'c' else 4.0 if nutrition_grade_fr == 'd' else 5.0 if nutrition_grade_fr == 'e' else 6.0)) 
print(food_df['nutrition_grade_fr'].unique())

"""Below we examine a violin plot with the countries on the x axis and the nutrition grade numbers as the y axis. While the graph does not perfectly illustrate our distribution because it treats nutrition grade as continuous when in fact it is discrete, it gives us a good idea of the grade distribution in each country or set of countries. Certain country categories such as the U.S., Switzerland, France, and the United Kingdom seem to have relatively uniform distributions across the grades. Other country categories do not do as well however, with all of Australia's foods having a B grade and all of the foods in "France,Spain" being given either a D or an E grade. Since different countries have different distributions, it suggests that countries may be a decent predictor of grade. However, we do have to worry about how robust the model will be to new entries in places like Australia, where the model may be biased to predict a B grade."""

plt.subplots(figsize=(12, 12))
plt.xticks(rotation='vertical')
plt.ylim([0.5, 5.5])
fig = sns.violinplot(x="countries_en", y="nutrition_grade_fr", data=food_df, cut=0,inner=None)

"""## 1.4 Dropping Null and Sparse Columns

After our past adjustments, we once again attempt to drop any columns that are completely null, and the print output below indicates that there were some.
"""

print("Number of columns before dropping null columns : %s" % (len(food_df.columns)))
food_df.dropna(axis=1,how='all', inplace=True)
print("Number of columns after dropping null columns : %s" % (len(food_df.columns)))

"""A further look seems to show that there are still sparse columns so we now will try to deal with those. Below we print the number of non-null datapoints in
each column.
"""

#TODO Get rid of columns that are too sparse to be used during machine learning
for column_name in food_df.columns :
  print("Number of non-null data points in %s : %s" % (column_name, len(food_df[[column_name]].dropna())))

"""Many of these columns have too few datapoints to be good predictors in a model. As some columns have as man as 252000 entries, we will drop all columns that do not have at least 100,000 datapoints and see where we stand from there. """

for column_name in food_df.columns :
  if len(food_df[[column_name]].dropna()) < 100000 :
         food_df.drop(column_name, axis=1, inplace=True)
for column_name in food_df.columns :
  print("Number of non-null data points in %s : %s" % (column_name, len(food_df[[column_name]].dropna())))

"""Importantly, we notice that after this last step, the categories predictor is gone. This means our ML models in the next section will not be able to use whether or note the item is a food, beverage, oil, cheese, etc. when it is classifying the foods. This will be a major differentiation between our model and existing models.

Before dropping any more null points, it will be instructive to look at the updated correlation matrix to see if there are any columns (hopefully some of the sparser ones) that we can drop.
"""

# TO-DO: Get the correlation matrix
from string import ascii_letters
correlation_matrix = food_df.corr()
sns.set(style = "white")
rs = np.random.RandomState(33)
d = pd.DataFrame(data=rs.normal(size=(100, 26)),
                 columns=list(ascii_letters[26:]))
corr = correlation_matrix
mask = np.zeros_like(corr, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True
f, ax = plt.subplots(figsize=(12, 12))
cmap = sns.diverging_palette(10, 220, as_cmap=True)
sns.heatmap(corr, mask=mask, cmap=cmap, vmax=1, vmin=-1, center=0,
            square=True, linewidths=.5, cbar_kws={"shrink": .5},xticklabels=True, yticklabels=True)
plt.title("Correlation Heatmap")
sns.set(font_scale=1)
plt.show()

"""Reassuringly, the updated correlation matrix has far few dark colors than the previous one. It does show a high correlation between salt and sodium. Referencing the relevant documentation, we are told that sodium and salt are direct multiples. Sodium is directly used to compute nutrition score and grade while salt is not, so we will keep sodium and drop salt."""

food_df.drop('salt_100g', axis=1, inplace=True)

"""Finally, in looking for categorical variables to drop, we will want to get rid of most of those that are "identifiers." That is, we would like to drop those that have a unique value for each datapoint, as they are unlikely to be useful in a general
machine learning model.
"""

for column_name in food_df.columns :
  if food_df[column_name].value_counts().count() > 1000:
    print("Number of unique data points in %s : %s" % (column_name, food_df[column_name].value_counts().count()))

"""From this, we see that code and url are both identifiers so we drop the latter. We also notice several duplicates such as last_modified_t and last_modified_datetime, brands and brands_tags, and additives, additivies_tags,
and additives_en. There were several above such as those that involved state and country,  so we drop them all here.
"""

food_df.drop(['url', 'last_modified_t', 'brands_tags', 'additives_tags', 'additives_en', 'countries', 'countries_tags', 'states', 'states_tags', 'created_t'], axis=1, inplace=True)

"""Looking at the non-null datapoints of the remaining columns below, we still have an issue of too much sparsity."""

for column_name in food_df.columns :
  print("Number of non-null data points in %s : %s" % (column_name, len(food_df[[column_name]].dropna())))

"""One way to solve this issue is to call dropna on 'vitamin-a_100g' in hopes of getting a fuller dataset. It took trial and error (which we have omitted) to discover that this was a good column to drop nulls from."""

food_df.dropna(subset=['vitamin-a_100g'], inplace=True)
food_df
for column_name in food_df.columns :
  print("Number of non-null data points in %s : %s" % (column_name, len(food_df[[column_name]].dropna())))

"""## 1.5 Imputation and Categorical to Numeric Conversion

It now looks like we have a relatively even dataset with small numbers of null values in numerous columns. At this point, we can fix that with imputation. We now give a final check to see if we have a class balance. The results below seem to support that our classes are relatively well balanced, so we may move forward.
"""

sns.set(font_scale=1)
p = sns.countplot(x='nutrition_grade_fr', data=food_df)
p.set(title='Grade Frequencies')

food_df[["nutrition_grade_fr"]].value_counts(normalize=True)

"""Here we convert our categorical variables to factors with -1 replacing null values. """

numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']
#Put all numeric columns into newdf1 and all categorical into newdf2
newdf1 = food_df.select_dtypes(include=numerics)
newdf2 =  food_df.drop(newdf1.columns, axis=1)
newdf2 = newdf2.apply(lambda x: pd.factorize(x)[0])
newdf2.reset_index(drop=True, inplace=True)

"""Here we do mean imputation of our initial set of numeric variables. Since many of the columns have null values, we have decided to not add columns that would control for this imputation because we worry that it would leave us with too many predictors."""

newdf1 = newdf1.apply(lambda x: x.fillna(x.mean()),axis=0)
newdf1.reset_index(drop=True, inplace=True)

"""Finally, we get our pre-processed dataframe!"""

food_df_final = pd.concat([newdf1,newdf2], axis=1,join='outer')

print(food_df_final.columns)

"""Next, we evaluate several features that we think may be important in impacting nutrition score. We explore histograms of various numerical parameters, partitioned by category. These both agree with conventional nutrition thinking. """

sns.displot(
    food_df_final, x="sugars_100g", col="nutrition_grade_fr",
    binwidth=3, height=3, facet_kws=dict(margin_titles=True), 
)

"""The distribtutions of sugar in each nutrition grade level above show us that sugar is increasing in grade. That is, a higher amount of sugar tends to correlate with a lower nutrition grade. This will likely turn out to be an important predictor for nutrition grade. """

sns.displot(
    food_df_final, x="additives_n", col="nutrition_grade_fr",
    binwidth=1, height=3, facet_kws=dict(margin_titles=True), 
)

"""The distribution of additives in each nutrition grade level above show us that additives are relatively evenly distributed across grades. This feature is therefore unlikely to be a good predictor for nutrition grade. Typically, we think of additives being unhealthy and non-nutritious. At least in the context of this dataset however, this does not seem to be the case."""

sns.displot(
    food_df_final, x="saturated-fat_100g", col="nutrition_grade_fr",
    binwidth=3, height=3, facet_kws=dict(margin_titles=True), 
)

"""Saturated fat, like sugar shows larger amounts of saturated fat correlating with worse nutrition grades. This, like sugar will likely be a strong predictor of nutrition grade. We note that conventional thinking would also lead us to the conclusion that less nutritious foods contain more saturated fat or sugar, and more nutritious foods contain less.

# **Part 2: Modeling**
"""

#Creating a copy for the Modelling Section
modelling_df = food_df_final.copy()

#Saving the columns for later use
cols = modelling_df.columns

#Converting to columns to float32
for col in cols:
    modelling_df[col] = np.float32(modelling_df[col])

#Extracting Features and Labels
import numpy as np
labels = np.array(modelling_df['nutrition_grade_fr'])
features= modelling_df.drop('nutrition_grade_fr', axis = 1)

#Storing the set of features for potential later use
features_storage = features.copy()
print(features.columns)
feature_list = list(features.columns)
features = np.array(features)

# Using Skicit-learn to split data into training and testing sets
from sklearn.model_selection import train_test_split
# Split the data into training and testing sets
train_features, test_features, train_labels, test_labels = train_test_split(features, labels, test_size = 0.25, random_state = 42)

print('Training Features Shape:', train_features.shape)
print('Training Labels Shape:', train_labels.shape)
print('Testing Features Shape:', test_features.shape)
print('Testing Labels Shape:', test_labels.shape)

"""##2.0 Decision Tree

It is useful to use a baseline classifier such as a decision tree so we can see how accurately we already can predict our target with a less complex model. We can then increase the complexity of the model with the hopes of also increasing test accuracy. The initial decision tree we use has default parameters meaning there is no max depth and the tree has the ability to split a node that only contains 2 datapoints, during training. Changes in impurity will be measured with gini impurity rather than information gain.
"""

from sklearn.tree import DecisionTreeClassifier 
clf = DecisionTreeClassifier(random_state=42)
clf = clf.fit(train_features,train_labels)

from sklearn import metrics
predictions = clf.predict(test_features)
print("Accuracy:",metrics.accuracy_score(test_labels, predictions))

"""Our decision tree already has a remarkably high degree of accuracy -- 93%! We note that the low minimum split parameter and the lack of a max depth may make our tree prone to overfitting. We will try and make adjustments to see if there is overfitting in subsequent sections. Directly below we show several methods of comparing true and false positive and negative rates. All of them show that for each class, our model is already doing a stellar job of classifying the foods to appropriate grades."""

from sklearn.metrics import classification_report
target_names = ['class 0', 'class 1','class 2','class 3','class 4']
predictions = clf.predict(test_features)
print(classification_report(test_labels, predictions, target_names=target_names))

"""Belowr we see the feature importance. Saturated fat (per 100g) is the most important followed closely by sodium, with sugars, fibers, and energy also having relatively high importance. Interestingly, many of the features have no importance at all and are not used by the high accuracy model. We will watch closely to see if this trend continues in future models."""

# Get numerical feature importances
importances = list(clf.feature_importances_)
# List of tuples with variable and importance
feature_importances = [(feature, round(importance, 2)) for feature, importance in zip(feature_list, importances)]
# Sort the feature importances by most important first
feature_importances = sorted(feature_importances, key = lambda x: x[1], reverse = True)
# Print out the feature and importances 
[print('Variable: {:20} Importance: {}'.format(*pair)) for pair in feature_importances];

!pip install graphviz

!pip install pydotplus

"""Below we have a visualization of the tree. It is quite large and has many leaves. We will attempt to make sure it does not overfit in the following sections."""

from sklearn.tree import export_graphviz
from six import StringIO
from IPython.display import Image  
import pydotplus

dot_data = StringIO()
export_graphviz(clf, out_file=dot_data,  
                filled=True, rounded=True,
                special_characters=True,feature_names = features_storage.columns,class_names=['class 0', 'class 1','class 2','class 3','class 4'])
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
graph.write_png('Decision Tree.png')
Image(graph.create_png())

"""## 2.1 Lower max depth Decision Tree

Here we somewhat naively try to cut down on the max depth of the decision tree. It is unclear if it was overfitting in the previous model thus far. However, it seems as if it is definitely underfitting in this model with an accuracy of only 0.72 displayed below.
"""

from sklearn.tree import DecisionTreeClassifier 
clf = DecisionTreeClassifier(max_depth=5, random_state=42)
clf = clf.fit(train_features,train_labels)

from sklearn import metrics
predictions = clf.predict(test_features)
print("Accuracy:",metrics.accuracy_score(test_labels, predictions))

"""In this weak model, the largest emphasis is placed on saturated fat, followed by sodium and sugars."""

# Get numerical feature importances
importances = list(clf.feature_importances_)
# List of tuples with variable and importance
feature_importances = [(feature, round(importance, 2)) for feature, importance in zip(feature_list, importances)]
# Sort the feature importances by most important first
feature_importances = sorted(feature_importances, key = lambda x: x[1], reverse = True)
# Print out the feature and importances 
[print('Variable: {:20} Importance: {}'.format(*pair)) for pair in feature_importances];

"""Below, we viualize this tree which is far simpler than the previous one."""

from sklearn.tree import export_graphviz
from six import StringIO
from IPython.display import Image  
import pydotplus

dot_data = StringIO()
export_graphviz(clf, out_file=dot_data,  
                filled=True, rounded=True,
                special_characters=True,feature_names = features_storage.columns,class_names=['class 0', 'class 1','class 2','class 3','class 4'])
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
graph.write_png('Optimized Decision Tree.png')
Image(graph.create_png())

"""### 2.1.1 Hyper Parameter Tuning for Decision Tree

We will now search for the optimized max_depth and minimum samples split for the tree using grid search cross validation. This method shows us that a max depth of 23 is optimal and that the minimum samples split of 2 is also best.
"""

#1070 seconds
from sklearn.model_selection import GridSearchCV

param_dict = {
    'max_depth' : range(10,30),
    'min_samples_split': range(2,10),
}
decision_tree = DecisionTreeClassifier(random_state=42)
grid = GridSearchCV(decision_tree, param_grid = param_dict, cv=5, verbose=1, n_jobs=-1)
grid.fit(train_features,train_labels)

grid.best_params_

grid.best_estimator_

# The best parameters are max depth: 19 and min_samples_split : 2

"""### 2.1.2 Optimized Decision Tree

After putting the optimal parameters into the model, we get a marginally lower accuracy which is likely to do with the randomness in the modeling process. Overall, there is not a big difference between this optimized model and our initial model, indicating that we were probably not overfitting initially. The feature importance is also almost identical to the initial model.
"""

from sklearn.tree import DecisionTreeClassifier 
clf = DecisionTreeClassifier(max_depth= 19, random_state=42)
clf = clf.fit(train_features,train_labels)
from sklearn import metrics
predictions = clf.predict(test_features)
print("Accuracy:",metrics.accuracy_score(test_labels, predictions))
from sklearn.metrics import classification_report
target_names = ['class 0', 'class 1','class 2','class 3','class 4']
predictions = clf.predict(test_features)
print(classification_report(test_labels, predictions, target_names=target_names))
# Get numerical feature importances
importances = list(clf.feature_importances_)
# List of tuples with variable and importance
feature_importances = [(feature, round(importance, 2)) for feature, importance in zip(feature_list, importances)]
# Sort the feature importances by most important first
feature_importances = sorted(feature_importances, key = lambda x: x[1], reverse = True)
# Print out the feature and importances 
[print('Variable: {:20} Importance: {}'.format(*pair)) for pair in feature_importances];




###Citation for the models: https://towardsdatascience.com/visualizing-decision-trees-with-python-scikit-learn-graphviz-matplotlib-1c50b4aa68dc
###, https://mljar.com/blog/visualize-decision-tree/, https://towardsdatascience.com/gridsearchcv-for-beginners-db48a90114ee,https://towardsdatascience.com/random-forest-in-python-24d0893d51c0

"""##2.2 Random Forest Model

Due to how well our decision tree just did, it makes sense to now expect even higher accuracy from an ensemble of decision trees. Therefore, we will bring in the random forest model. Once again we will start by simply using the default parameters of the RandomForestClassifier from sklearn. This has no max depth and uses 100 trees in the forest.
"""

# Import the model we are using
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_selection import SelectFromModel
rf = RandomForestClassifier(random_state=42)
# Train the model on training data
rf.fit(train_features, train_labels);

from sklearn import metrics
predictions = rf.predict(test_features)
print("Accuracy:",metrics.accuracy_score(test_labels, predictions))

"""As seen above, the model does not disappoint and we have achieved a marginal increase in accuracy -- which is now up to 94% -- from the decision tree model! Below, we once again show a number of metrics measuring ratios between true and false negatives and positives. These numbers are similar to that of the decision tree, but are generally a little better."""

from sklearn.metrics import classification_report
target_names = ['class 0', 'class 1','class 2','class 3','class 4']
predictions = rf.predict(test_features)
print(classification_report(test_labels, predictions, target_names=target_names))

"""Finally, we again investigate the importance of the features in our model. Saturated fat and sodium are still the two most important features. We find that the random forest has put less weight on them than did the decision tree however. Energy, sugars, and fibers remain important. Fifth in importance is fat which makes sense since we know from our EDA that it is well correlated with saturated fat. Carbohydrates, and protein are the remaining three that have at least 0.05 importance. Carbohydrates are well correlated with sugars and so it is not surprising that they are important. Protein is not well correlated with any other predictors so we now know it may have some importance in prediction. A number of other features are non-zero but have very low importance of < 0.05. Only a few features have actually been zeroed out under the random forest model. """

# Get numerical feature importances
importances = list(rf.feature_importances_)
# List of tuples with variable and importance
feature_importances = [(feature, round(importance, 2)) for feature, importance in zip(feature_list, importances)]
# Sort the feature importances by most important first
feature_importances = sorted(feature_importances, key = lambda x: x[1], reverse = True)
# Print out the feature and importances 
[print('Variable: {:20} Importance: {}'.format(*pair)) for pair in feature_importances];

"""### 2.2.1 Hyper Parameter Tuning for Random Forest

We now test different max depths and forest sizes to see if we can increase our accuracy by a significan amount. Increasing forest size will almost definitely increase accuracy but it is not clear if that amount will make much of a difference. Again using grid search cross validation, we find optimal parameters of a max depth of 25 (the max depth we tried) and a forest size of 1000 (the max size we tried).

Note: the following code takes over an hour to run so we have commented it out. We do have the result from it.
"""

# from sklearn.model_selection import GridSearchCV

# param_dict = {
#     'max_depth' : [15,20,25],
#     'n_estimators': [100, 200,400,600,800,1000],
# }
# random_forest = RandomForestClassifier(random_state=42)
# grid = GridSearchCV(random_forest, param_grid = param_dict, cv=5, verbose=1, n_jobs=-1)
# grid.fit(train_features,train_labels)
# print(grid.best_params_)
# print(grid.best_estimator_)


# The best parameters are max depth: 25 and n_estimators : 1000

"""### 2.2.2 Optimized Random Forest

Running the model with these optimized parameters, we again see only very small improvements in our accuracy. This is probably a result of a forest of size 1000 being far beyond the knee point for accuracy. Once again, there are virtually no differences between the other metrics of performance or the feature importance.
"""

#400 secs
# Import the model we are using
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_selection import SelectFromModel
# Instantiate model with 1000 decision trees
rf = RandomForestClassifier(max_depth= 25, n_estimators= 1000, random_state=42)
# Train the model on training data
rf.fit(train_features, train_labels);
from sklearn import metrics
predictions = rf.predict(test_features)
print("Accuracy:",metrics.accuracy_score(test_labels, predictions))
from sklearn.metrics import classification_report
target_names = ['class 0', 'class 1','class 2','class 3','class 4']
predictions = rf.predict(test_features)
print(classification_report(test_labels, predictions, target_names=target_names))
# Get numerical feature importances
importances = list(rf.feature_importances_)
# List of tuples with variable and importance
feature_importances = [(feature, round(importance, 2)) for feature, importance in zip(feature_list, importances)]
# Sort the feature importances by most important first
feature_importances = sorted(feature_importances, key = lambda x: x[1], reverse = True)
# Print out the feature and importances 
[print('Variable: {:20} Importance: {}'.format(*pair)) for pair in feature_importances];

"""##2.3 AdaBoost Model

Boosting may do better than a random forest in some cases. Using an AdaBoost model with a decision stump as our base classifier, a learning rate of 1, and 50 iterations, we see if this ensemble method offers a better result than our currently most accurate classifier.
"""

from sklearn.ensemble import AdaBoostClassifier
adamodel = AdaBoostClassifier(random_state=42)
adamodel.fit(train_features, train_labels)

from sklearn import metrics
predictions = adamodel.predict(test_features)
print("Accuracy:",metrics.accuracy_score(test_labels, predictions))

"""The accuracy of this method is much lower than that of the previous two. This may suggest that the true hypothesis class is closer to that of a deep decision tree. Below, the model does worse on every metric than do the previous two models meaning that the classification is weaker in every aspect."""

from sklearn.metrics import classification_report
target_names = ['class 0', 'class 1','class 2','class 3','class 4']
predictions = adamodel.predict(test_features)
print(classification_report(test_labels, predictions, target_names=target_names))

"""Once again looking at importance of our predictors, we see that saturated fat, sugars, and states are tied as the most important ones. After that, energy, sodium, fiber, protein, and additives also are greater than 0.05 importance. Based on our previous models, none of these is surprising except perhaps states. States is a (converted) categorical variable that indicates the status of whether or not a given food item has things like completed nutrition facts, completed ingredients, completed expiration date, etc. The fact that this is important tells us that the amount of data for each item may have predictive power in telling us its nutrition grade. """

# Get numerical feature importances
importances = list(adamodel.feature_importances_)
# List of tuples with variable and importance
feature_importances = [(feature, round(importance, 2)) for feature, importance in zip(feature_list, importances)]
# Sort the feature importances by most important first
feature_importances = sorted(feature_importances, key = lambda x: x[1], reverse = True)
# Print out the feature and importances 
[print('Variable: {:20} Importance: {}'.format(*pair)) for pair in feature_importances];

"""### 2.3.1 Hyper Parameter Tuning for AdaBoost

Doing our best to optimize the learning rate and the number of iterations within the adaboost training, we find that both should be high. 1000 iterations and a very high learning rate of 1.5 will both help to increase the test accuracy of the model. We don't attempt larger numbers of iterations due to long runtimes.

Note: the following code takes over an hour to run so we have commented it out. We do have the result from it.
"""

# from sklearn.model_selection import GridSearchCV

# param_dict = {
#     'n_estimators': [100, 200,400,600,800,1000],
#     'learning_rate':[0.1, 1, 1.5]
# }
# ada_boost_model = AdaBoostClassifier(random_state=42)
# grid = GridSearchCV(ada_boost_model, param_grid = param_dict, cv=5, verbose=1, n_jobs=-1)
# grid.fit(train_features,train_labels)
# print(grid.best_params_)
# print(grid.best_estimator_)


# The best parameters are learning_rate : 1.5 and n_estimators : 1000

"""### 2.3.2 Optimized AdaBoost

Under the optimized model, we do see a significant increase in accuracy now up to 0.67 from 0.63. The feature importance is re-shuffled with saturated fat and sodium both being unusually know. All this being said, this model is still nowhere near our random forest model in terms of test accuracy, so we will look to find a better model if possible.
"""

#5 mins to run
from sklearn.ensemble import AdaBoostClassifier
adamodel = AdaBoostClassifier(random_state=42, learning_rate = 1.5, n_estimators = 1000)
adamodel.fit(train_features, train_labels)
from sklearn import metrics
predictions = adamodel.predict(test_features)
print("Accuracy:",metrics.accuracy_score(test_labels, predictions))
from sklearn.metrics import classification_report
target_names = ['class 0', 'class 1','class 2','class 3','class 4']
predictions = adamodel.predict(test_features)
print(classification_report(test_labels, predictions, target_names=target_names))
# Get numerical feature importances
importances = list(adamodel.feature_importances_)
# List of tuples with variable and importance
feature_importances = [(feature, round(importance, 2)) for feature, importance in zip(feature_list, importances)]
# Sort the feature importances by most important first
feature_importances = sorted(feature_importances, key = lambda x: x[1], reverse = True)
# Print out the feature and importances 
[print('Variable: {:20} Importance: {}'.format(*pair)) for pair in feature_importances];

"""## 2.4 Gradient Boosting Model (with XGboost)

Gradient boosting often outperforms AdaBoost and under correct circumstances, may outperform random forests. Here, we try this final ensemble method in an attempt to beat the currently dominant random forest classifier. We once again use low depth decision trees as our base learners.
"""

from xgboost import XGBClassifier
xgmodel = XGBClassifier(random_state=42)
xgmodel.fit(train_features, train_labels)

from sklearn import metrics
predictions = xgmodel.predict(test_features)
print("Accuracy:",metrics.accuracy_score(test_labels, predictions))

"""As expected, we have increased accuracy from AdaBoost. However, in this case, gradient boosting does not seem to live up to the random forest model that we made previously. The validation accuracy of 87% shown above, is still lower than the 94% given by the random forest, and even the 93% given by the basic decision tree. The metrics below are generally much better than AdaBoost and in some cases similar to those in the first two models.  """

from sklearn.metrics import classification_report
target_names = ['class 0', 'class 1','class 2','class 3','class 4']
predictions = xgmodel.predict(test_features)
print(classification_report(test_labels, predictions, target_names=target_names))

"""Our most important variables are no surprise at this point, with saturated fat, energy, sugars, sodium, proteins, fiber, and fat once again taking top spots."""

# Get numerical feature importances
importances = list(xgmodel.feature_importances_)
# List of tuples with variable and importance
feature_importances = [(feature, round(importance, 2)) for feature, importance in zip(feature_list, importances)]
# Sort the feature importances by most important first
feature_importances = sorted(feature_importances, key = lambda x: x[1], reverse = True)
# Print out the feature and importances 
[print('Variable: {:20} Importance: {}'.format(*pair)) for pair in feature_importances];

"""## Summary of Models

After running the previous models, we now summarize our findings. Our most accurate in descending order of accuracy ended up being an optimized random forest, an optimized decision tree, an un-optimized gradient boosting model, and an optimized AdaBoost model. All models gave relatively high importance to saturated fat, sodium, and energy. Meanwile, no models gave importance to  trans fat or ingredients that may be from palm oil. While sugars, proteins and fibers regularly were of high importance, most other features regularly had very low or no importance, suggesting that only a few of the features were actually crucial in the modeling.

With the random forest, we now have our own classifier of Nutri-Score which is robust to category of consumable and can be predicted by easily measured features!

# **Part 3: Obstacles and Challenges**
## 3.1 Sparse Columns
Our first major challenge was the large amount of null values in the dataset, both for our target variable and across many other columns. It was hard to guess which columns could be important when so many of them had many null values. We knew imputation would be implausible from the beginning, so it became our task to cut down the data as much as possible which required a fair bit of critcal thinking. 

## 3.2 Nutrition Score and Bias
Next, we encountered the problem of whether there is bias inherent in who decides the labeling of the dataset. For exmample, does using a UK nutrition score label bias our notion of "nutrition value" toward standards fvorable to English and European foods? Additionally, does this bias our location based nutrition factors toward European food items? We decided that based on our dataset, the French nutrition score was optimal because of the large number of diverse food items that were categorized under a French score. Additionally, the very high correlation in scores for the same items between French and English Nutri-Scores was indicative of low variability based on location for nutrition score. This inspired confidence in using a singular country's ranking as the standard.

## 3.3 Runtime

Some code setions, including the hyperparamter tuning for all models took a long time to run, sometimes in excess of 20 minutes or more. This hurt the efficiency of our feedback and development loops. For the reason or runtime, we were unable to do what we wanted in order to optimize our gradient boosting.

In response, we worked in parallel across multiple aspects of the project, working on additional charts and data analysis while models ran, and parallelizing our notebook acros multiple instances to prevent merge conflicts.

# **Part 4: Conclusion and Next Steps**

## 4.1 Summary

In this project, we explored the Open Food Facts dataset, and focused on the factors that cause food to be more or less nutritious. Tthe focus of our exploratory data analysis was finding and isolating important variables that affect the nutrition score, while also getting rid of unimportant and null variables along the way. We utilized heatmaps of correlations, analysis of scores across countries and inter-country relationships, as well as histograms partitioned by nutrition score category. We paid careful attention to removing nulls, mostly through deletion and partially through imputation. We then proceeded to use a number of off-the-shelf models to try and predict the Nutri-Score.

We began with a naive decision tree model which we then tried pruning before simply using grid search to optimize parameters. Due to the success of this model, we then proceeded to try a random forest which was met with even more success in terms of accuracy, especially after hyperparameter tuning. We then decided to try boosting as we know that can often be successful with classification models. First we tried AdaBoost with which we had limited success even after parameter optimization. We then tried gradient boosting using XGboost which outperformed Adaboost but still did not match the level of our random forest.

## 4.2 Ethical Concerns

As opposed to the actual algorithms used to find Nutri-Score in different countries, our algorithm does not place hard cutoffs on amounts of certain ingredients in a given food, beverage, oil, or cheese. We then face a worry that we have a grave misclassifciation. Although we generally have a similar classification to that of France, it is possible there exists an item that could be placed into our best model that might have a lot of sugar and sodium and generally non-nutritous contents. If our model misclassified this with a high grade like an A, and was used to  assign a Nutri-Score, people may buy the item thinking that it's nutritious when in fact it's not. This is an ethical concern but its unclear how likely an extreme case like this is.

## 4.3 Next Steps

We have not used neural networks in this project. It is unclear if they would do better than our random forest model but it may be interesting to try and see in the future.

An alternative exciting next step would be developing our own target metric for food and nutrition quality. Rather than optimizing for a Nutrition Score, we could try to build a new score based on outcomes in real life. 

For example, joining our data with a dataset about a trial group's detailed food consumption and health outcomes, including weight loss.
"""